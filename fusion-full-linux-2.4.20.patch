diff -uraN linux-2.4.20/drivers/char/Config.in linux-2.4.20-fusion/drivers/char/Config.in
--- linux-2.4.20/drivers/char/Config.in	2002-11-29 13:18:31.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/Config.in	2003-04-07 14:51:31.000000000 +0200
@@ -248,6 +248,7 @@
 fi
 dep_tristate 'AMD 76x native power management (Experimental)' CONFIG_AMD_PM768 $CONFIG_PCI
 tristate '/dev/nvram support' CONFIG_NVRAM
+tristate 'Fusion Kernel Device' CONFIG_FUSION_DEVICE
 tristate 'Enhanced Real Time Clock Support' CONFIG_RTC
 if [ "$CONFIG_IA64" = "y" ]; then
    bool 'EFI Real Time Clock Services' CONFIG_EFI_RTC
diff -uraN linux-2.4.20/drivers/char/fusion/call.c linux-2.4.20-fusion/drivers/char/fusion/call.c
--- linux-2.4.20/drivers/char/fusion/call.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/call.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,447 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "call.h"
+
+typedef struct {
+  FusionLink        link;
+
+  int               caller;
+
+  int               ret_val;
+
+  bool              executed;
+
+  wait_queue_head_t wait;
+} FusionCallExecution;
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;        /* call id */
+
+  int                pid;       /* owner pid */
+  int                fusion_id; /* owner fusion id */
+
+  FusionCallHandler  handler;
+  void              *ctx;
+
+  FusionLink          *executions;      /* prepending! */
+  FusionCallExecution *next;            /* points to the last item of executions */
+
+  int                count;    /* number of calls ever made */
+} FusionCall;
+
+/******************************************************************************/
+
+static FusionCall *lookup_call (int id);
+
+static FusionCall *lock_call   (int id);
+static void        unlock_call (FusionCall *call);
+
+static FusionCallExecution *add_execution       (FusionCall          *call,
+                                                 int                  fusion_id,
+                                                 FusionCallExecute   *execute);
+static void                 remove_execution    (FusionCall          *call,
+                                                 FusionCallExecution *execution);
+static void                 free_all_executions (FusionCall          *call);
+
+/******************************************************************************/
+
+static int         ids        = 0;
+static FusionLink *calls      = NULL;
+static spinlock_t  calls_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_call_read_proc (char *buf, char **start, off_t offset,
+                       int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&calls_lock);
+
+  fusion_list_foreach (l, calls)
+    {
+      FusionCall *call = (FusionCall*) l;
+
+      written += sprintf(buf+written,
+                         "(%5d) 0x%08x (%d calls) %s\n",
+                         call->pid, call->id, call->count,
+                         call->next ? "executing" : "idle");
+
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&calls_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_call_init()
+{
+  create_proc_read_entry("calls", 0, proc_fusion_dir,
+                         fusion_call_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_call_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  l = calls;
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionCall *call = (FusionCall *) l;
+
+      free_all_executions (call);
+
+      kfree (call);
+
+      l = next;
+    }
+
+  ids   = 0;
+  calls = NULL;
+
+  spin_unlock (&calls_lock);
+}
+
+void
+fusion_call_cleanup()
+{
+  fusion_call_reset();
+
+  remove_proc_entry ("calls", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_call_new (int fusion_id, FusionCallNew *call_new)
+{
+  FusionCall *call;
+
+  call = kmalloc (sizeof(FusionCall), GFP_KERNEL);
+  if (!call)
+    return -ENOMEM;
+
+  memset (call, 0, sizeof(FusionCall));
+
+  spin_lock (&calls_lock);
+
+  call->id        = ids++;
+  call->pid       = current->pid;
+  call->fusion_id = fusion_id;
+  call->lock      = SPIN_LOCK_UNLOCKED;
+
+  call->handler   = call_new->handler;
+  call->ctx       = call_new->ctx;
+
+  fusion_list_prepend (&calls, &call->link);
+
+  spin_unlock (&calls_lock);
+
+  call_new->call_id = call->id;
+
+  return 0;
+}
+
+int
+fusion_call_execute (int fusion_id, FusionCallExecute *execute)
+{
+  int                  ret;
+  FusionCall          *call;
+  FusionCallExecution *execution;
+  FusionCallMessage    message;
+
+  call = lock_call (execute->call_id);
+  if (!call)
+    return -EINVAL;
+
+  execution = add_execution (call, fusion_id, execute);
+  if (!execution)
+    {
+      unlock_call (call);
+      return -ENOMEM;
+    }
+  
+  /* Send call message. */
+  message.handler  = call->handler;
+  message.ctx      = call->ctx;
+
+  message.caller   = execution->caller;
+
+  message.call_arg = execute->call_arg;
+  message.call_ptr = execute->call_ptr;
+
+  ret = fusionee_send_message (fusion_id, call->fusion_id, FMT_CALL,
+                               call->id, sizeof(message), &message);
+  if (ret)
+    {
+      remove_execution (call, execution);
+      unlock_call (call);
+      return ret;
+    }
+
+  call->count++;
+
+  fusion_sleep_on (&execution->wait, &call->lock);
+      
+  call = lock_call (execute->call_id);
+  if (!call)
+    return -EIDRM;
+
+  execute->ret_val = execution->ret_val;
+
+  remove_execution (call, execution);
+
+  kfree (execution);
+
+  if (signal_pending(current))
+    {
+      unlock_call (call);
+      return -ERESTARTSYS;
+    }
+
+  unlock_call (call);
+
+  return 0;
+}
+
+int
+fusion_call_return (int fusion_id, FusionCallReturn *call_ret)
+{
+  FusionLink *l;
+  FusionCall *call = lock_call (call_ret->call_id);
+
+  if (!call)
+    return -EINVAL;
+
+  fusion_list_foreach (l, call->executions)
+    {
+      FusionCallExecution *execution = (FusionCallExecution*) l;
+
+      if (execution->executed)
+        continue;
+
+      execution->ret_val  = call_ret->val;
+      execution->executed = true;
+
+      wake_up_interruptible_all (&execution->wait);
+
+      unlock_call (call);
+
+      return 0;
+    }
+
+  unlock_call (call);
+
+  return -EIO;
+}
+
+int
+fusion_call_destroy (int fusion_id, int call_id)
+{
+  FusionCall *call = lookup_call (call_id);
+
+  if (!call)
+    return -EINVAL;
+
+  if (call->fusion_id != fusion_id)
+    {
+      spin_unlock (&calls_lock);
+      return -EIO;
+    }
+
+  spin_lock (&call->lock);
+
+  fusion_list_remove (&calls, &call->link);
+
+  free_all_executions (call);
+
+  spin_unlock (&calls_lock);
+
+  kfree (call);
+
+  return 0;
+}
+
+void
+fusion_call_destroy_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  l = calls;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionCall *call = (FusionCall *) l;
+
+      spin_lock (&call->lock);
+
+      if (call->fusion_id == fusion_id)
+        {
+          free_all_executions (call);
+
+          fusion_list_remove (&calls, &call->link);
+
+          kfree (call);
+        }
+      else
+        spin_unlock (&call->lock);
+
+      l = next;
+    }
+
+  spin_unlock (&calls_lock);
+}
+
+/******************************************************************************/
+
+static FusionCall *
+lookup_call (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&calls_lock);
+
+  fusion_list_foreach (l, calls)
+    {
+      FusionCall *call = (FusionCall *) l;
+
+      if (call->id == id)
+        return call;
+    }
+
+  spin_unlock (&calls_lock);
+
+  return NULL;
+}
+
+static FusionCall *
+lock_call (int id)
+{
+  FusionCall *call = lookup_call (id);
+
+  if (call)
+    {
+      fusion_list_move_to_front (&calls, &call->link);
+
+      spin_lock (&call->lock);
+      spin_unlock (&calls_lock);
+    }
+
+  return call;
+}
+
+static void
+unlock_call (FusionCall *call)
+{
+  spin_unlock (&call->lock);
+}
+
+static FusionCallExecution *
+add_execution (FusionCall        *call,
+               int                fusion_id,
+               FusionCallExecute *execute)
+{
+  FusionCallExecution *execution;
+
+  /* Allocate execution. */
+  execution = kmalloc (sizeof(FusionCallExecution), GFP_KERNEL);
+  if (!execution)
+    return NULL;
+
+  /* Initialize execution. */
+  memset (execution, 0, sizeof(FusionCallExecution));
+
+  execution->caller = fusion_id;
+
+  init_waitqueue_head (&execution->wait);
+
+  /* Add execution. */
+  fusion_list_prepend (&call->executions, &execution->link);
+
+  if (!call->next)
+    call->next = execution;
+
+  return execution;
+}
+
+static void
+remove_execution (FusionCall          *call,
+                  FusionCallExecution *execution)
+{
+  if (call->next == execution)
+    call->next = (FusionCallExecution*) execution->link.prev;
+
+  fusion_list_remove (&call->executions, &execution->link);
+}
+
+static void
+free_all_executions (FusionCall *call)
+{
+  while (call->next)
+    {
+      FusionCallExecution *execution = call->next;
+
+      remove_execution (call, execution);
+
+      wake_up_interruptible_all (&execution->wait);
+
+      kfree (execution);
+    }
+}
diff -uraN linux-2.4.20/drivers/char/fusion/call.h linux-2.4.20-fusion/drivers/char/fusion/call.h
--- linux-2.4.20/drivers/char/fusion/call.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/call.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__CALL_H__
+#define __FUSION__CALL_H__
+
+#include <linux/fusion.h>
+
+
+/* module init/cleanup */
+
+int  fusion_call_init (void);
+void fusion_call_reset (void);
+void fusion_call_cleanup (void);
+
+
+/* public API */
+
+int fusion_call_new (int fusion_id, FusionCallNew *call);
+int fusion_call_execute (int fusion_id, FusionCallExecute *execute);
+int fusion_call_return (int fusion_id, FusionCallReturn *call_ret);
+int fusion_call_destroy (int fusion_id, int call_id);
+
+
+/* internal functions */
+
+void fusion_call_destroy_all (int fusion_id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/fifo.c linux-2.4.20-fusion/drivers/char/fusion/fifo.c
--- linux-2.4.20/drivers/char/fusion/fifo.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fifo.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "fifo.h"
+
+void
+fusion_fifo_put (FusionFifo *fifo, FusionLink *link)
+{
+  link->prev = fifo->last;
+  link->next = NULL;
+
+  if (fifo->last)
+    fifo->last->next = link;
+  else
+    fifo->first = link;
+
+  fifo->last = link;
+
+  fifo->count++;
+}
+
+FusionLink *
+fusion_fifo_get (FusionFifo *fifo)
+{
+  FusionLink *first = fifo->first;
+
+  if (!first)
+    return NULL;
+
+  fifo->first = first->next;
+
+  if (fifo->last == first)
+    fifo->last = NULL;
+  else
+    fifo->first->prev = NULL;
+
+  fifo->count--;
+
+  return first;
+}
diff -uraN linux-2.4.20/drivers/char/fusion/fifo.h linux-2.4.20-fusion/drivers/char/fusion/fifo.h
--- linux-2.4.20/drivers/char/fusion/fifo.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fifo.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__FIFO_H__
+#define __FUSION__FIFO_H__
+
+#include "types.h"
+#include "list.h"
+
+typedef struct {
+  FusionLink *first;
+  FusionLink *last;
+
+  int         count;
+} FusionFifo;
+
+void        fusion_fifo_put   (FusionFifo *fifo,
+                               FusionLink *link);
+
+FusionLink *fusion_fifo_get   (FusionFifo *fifo);
+
+int         fusion_fifo_count (FusionFifo *fifo);
+
+//#define fusion_list_foreach(link, list)  for (link = list; link; link = link->next)
+
+#endif /* __FUSION__LIST_H__ */
+
diff -uraN linux-2.4.20/drivers/char/fusion/fusiondev.c linux-2.4.20-fusion/drivers/char/fusion/fusiondev.c
--- linux-2.4.20/drivers/char/fusion/fusiondev.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fusiondev.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,522 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/module.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/proc_fs.h>
+#include <linux/poll.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+#define DEBUG(x...)  printk (KERN_DEBUG "Fusion: " x)
+
+#ifndef FUSION_MINOR
+#define FUSION_MINOR 23
+#endif
+
+MODULE_LICENSE("GPL");
+
+struct proc_dir_entry *proc_fusion_dir;
+
+static int        refs      = 0;
+static spinlock_t refs_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+void
+fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock)
+{
+  unsigned long flags;
+  wait_queue_t  wait;
+  
+  init_waitqueue_entry (&wait, current);
+
+  current->state = TASK_INTERRUPTIBLE;
+
+  wq_write_lock_irqsave (&q->lock,flags);
+  __add_wait_queue (q, &wait);
+  wq_write_unlock (&q->lock);
+
+  spin_unlock (lock);
+
+  schedule();
+
+  wq_write_lock_irq (&q->lock);
+  __remove_wait_queue (q, &wait);
+  wq_write_unlock_irqrestore (&q->lock,flags);
+}
+
+/******************************************************************************/
+
+static void
+fusion_reset (void)
+{
+  fusion_call_reset();
+  fusion_reactor_reset();
+  fusion_property_reset();
+  fusion_skirmish_reset();
+  fusion_ref_reset();
+  fusionee_reset();
+}
+
+/******************************************************************************/
+
+static int
+fusion_open (struct inode *inode, struct file *file)
+{
+  int ret;
+  int fusion_id;
+
+  spin_lock (&refs_lock);
+
+  ret = fusionee_new (&fusion_id);
+  if (ret)
+    {
+      spin_unlock (&refs_lock);
+
+      return ret;
+    }
+
+  refs++;
+
+  spin_unlock (&refs_lock);
+
+
+  file->private_data = (void*) fusion_id;
+
+  return 0;
+}
+
+static int
+fusion_release (struct inode *inode, struct file *file)
+{
+  int fusion_id = (int) file->private_data;
+
+  fusionee_destroy (fusion_id);
+
+  spin_lock (&refs_lock);
+
+  if (! --refs)
+    fusion_reset();
+
+  spin_unlock (&refs_lock);
+
+  return 0;
+}
+
+static ssize_t
+fusion_read (struct file *file, char *buf, size_t count, loff_t *ppos)
+{
+  int fusion_id = (int) file->private_data;
+
+  return fusionee_get_messages (fusion_id, buf, count,
+                                !(file->f_flags & O_NONBLOCK));
+}
+
+static unsigned int
+fusion_poll (struct file *file, poll_table * wait)
+{
+  int fusion_id = (int) file->private_data;
+
+  return fusionee_poll (fusion_id, file, wait);
+}
+
+static int
+fusion_ioctl (struct inode *inode, struct file *file,
+              unsigned int cmd, unsigned long arg)
+{
+  int id;
+  int ret;
+  int refs;
+  int fusion_id = (int) file->private_data;
+  FusionSendMessage     send;
+  FusionReactorDispatch dispatch;
+  FusionCallNew         call;
+  FusionCallExecute     execute;
+  FusionCallReturn      call_ret;
+
+  switch (cmd)
+    {
+    case FUSION_GET_ID:
+      if (put_user (fusion_id, (int*) arg))
+        return -EFAULT;
+
+      break;
+
+    case FUSION_SEND_MESSAGE:
+      if (copy_from_user (&send, (FusionSendMessage*) arg, sizeof(send)))
+        return -EFAULT;
+
+      if (send.msg_size <= 0)
+        return -EINVAL;
+
+      /* message data > 64k should be stored in shared memory */
+      if (send.msg_size > 0x10000)
+        return -EMSGSIZE;
+
+      return fusionee_send_message (fusion_id, send.fusion_id, FMT_SEND, send.msg_id,
+                                    send.msg_size, send.msg_data);
+
+
+    case FUSION_CALL_NEW:
+      if (copy_from_user (&call, (FusionCallNew*) arg, sizeof(call)))
+        return -EFAULT;
+
+      ret = fusion_call_new (fusion_id, &call);
+      if (ret)
+        return ret;
+
+      if (put_user (call.call_id, (int*) arg))
+        {
+          fusion_call_destroy (fusion_id, call.call_id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_CALL_EXECUTE:
+      if (copy_from_user (&execute, (FusionCallExecute*) arg, sizeof(execute)))
+        return -EFAULT;
+
+      ret = fusion_call_execute (fusion_id, &execute);
+      if (ret)
+        return ret;
+
+      if (put_user (execute.ret_val, (int*) arg))
+        return -EFAULT;
+      break;
+
+    case FUSION_CALL_RETURN:
+      if (copy_from_user (&call_ret, (FusionCallReturn*) arg, sizeof(call_ret)))
+        return -EFAULT;
+
+      return fusion_call_return (fusion_id, &call_ret);
+
+    case FUSION_CALL_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_call_destroy (fusion_id, id);
+
+
+    case FUSION_REF_NEW:
+      ret = fusion_ref_new (&id);
+      if (ret)
+        return ret;
+
+      if (put_user (id, (int*) arg))
+        {
+          fusion_ref_destroy (id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_REF_UP:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_up (id, fusion_id);
+
+    case FUSION_REF_UP_GLOBAL:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_up (id, 0);
+
+    case FUSION_REF_DOWN:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_down (id, fusion_id);
+
+    case FUSION_REF_DOWN_GLOBAL:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_down (id, 0);
+
+    case FUSION_REF_ZERO_LOCK:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_zero_lock (id);
+
+    case FUSION_REF_ZERO_TRYLOCK:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_zero_trylock (id);
+
+    case FUSION_REF_UNLOCK:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_unlock (id);
+
+    case FUSION_REF_STAT:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      ret = fusion_ref_stat (id, &refs);
+      if (ret)
+        return ret;
+
+      return refs;
+
+    case FUSION_REF_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_ref_destroy (id);
+
+
+    case FUSION_SKIRMISH_NEW:
+      ret = fusion_skirmish_new (&id);
+      if (ret)
+        return ret;
+
+      if (put_user (id, (int*) arg))
+        {
+          fusion_skirmish_destroy (id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_SKIRMISH_PREVAIL:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_skirmish_prevail (id, fusion_id);
+
+    case FUSION_SKIRMISH_SWOOP:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_skirmish_swoop (id, fusion_id);
+
+    case FUSION_SKIRMISH_DISMISS:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_skirmish_dismiss (id, fusion_id);
+
+    case FUSION_SKIRMISH_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_skirmish_destroy (id);
+
+
+    case FUSION_PROPERTY_NEW:
+      ret = fusion_property_new (&id);
+      if (ret)
+        return ret;
+
+      if (put_user (id, (int*) arg))
+        {
+          fusion_property_destroy (id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_PROPERTY_LEASE:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_property_lease (id, fusion_id);
+
+    case FUSION_PROPERTY_PURCHASE:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_property_purchase (id, fusion_id);
+
+    case FUSION_PROPERTY_CEDE:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_property_cede (id, fusion_id);
+
+    case FUSION_PROPERTY_HOLDUP:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_property_holdup (id, fusion_id);
+
+    case FUSION_PROPERTY_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_property_destroy (id);
+
+
+    case FUSION_REACTOR_NEW:
+      ret = fusion_reactor_new (&id);
+      if (ret)
+        return ret;
+
+      if (put_user (id, (int*) arg))
+        {
+          fusion_reactor_destroy (id);
+          return -EFAULT;
+        }
+      break;
+
+    case FUSION_REACTOR_ATTACH:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_reactor_attach (id, fusion_id);
+
+    case FUSION_REACTOR_DETACH:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_reactor_detach (id, fusion_id);
+
+    case FUSION_REACTOR_DISPATCH:
+      if (copy_from_user (&dispatch,
+                          (FusionReactorDispatch*) arg, sizeof(dispatch)))
+        return -EFAULT;
+
+      if (dispatch.msg_size <= 0)
+        return -EINVAL;
+
+      /* message data > 64k should be stored in shared memory */
+      if (dispatch.msg_size > 0x10000)
+        return -EMSGSIZE;
+
+      return fusion_reactor_dispatch (dispatch.reactor_id,
+                                      dispatch.self ? 0 : fusion_id,
+                                      dispatch.msg_size, dispatch.msg_data);
+
+    case FUSION_REACTOR_DESTROY:
+      if (get_user (id, (int*) arg))
+        return -EFAULT;
+
+      return fusion_reactor_destroy (id);
+
+
+    default:
+      return -ENOTTY;
+    }
+
+  return 0;
+}
+
+static struct file_operations fusion_fops = {
+  .owner   = THIS_MODULE,
+  .open    = fusion_open,
+  .release = fusion_release,
+  .read    = fusion_read,
+  .poll    = fusion_poll,
+  .ioctl   = fusion_ioctl
+};
+
+static struct miscdevice fusion_miscdev = {
+  .minor   = FUSION_MINOR,
+  .name    = "fusion",
+  .fops    = &fusion_fops
+};
+
+/******************************************************************************/
+
+int __init
+fusion_init(void)
+{
+  int ret;
+
+  proc_fusion_dir = proc_mkdir ("fusion", NULL);
+
+  ret = fusionee_init();
+  if (ret)
+    goto error_fusionee;
+
+  ret = fusion_ref_init();
+  if (ret)
+    goto error_ref;
+
+  ret = fusion_skirmish_init();
+  if (ret)
+    goto error_skirmish;
+
+  ret = fusion_property_init();
+  if (ret)
+    goto error_property;
+
+  ret = fusion_reactor_init();
+  if (ret)
+    goto error_reactor;
+
+  ret = fusion_call_init();
+  if (ret)
+    goto error_call;
+
+  ret = misc_register (&fusion_miscdev);
+  if (ret)
+    goto error_misc;
+
+  return 0;
+
+
+ error_misc:
+  fusion_call_cleanup();
+
+ error_call:
+  fusion_reactor_cleanup();
+
+ error_reactor:
+  fusion_property_cleanup();
+
+ error_property:
+  fusion_skirmish_cleanup();
+
+ error_skirmish:
+  fusion_ref_cleanup();
+
+ error_ref:
+  fusionee_cleanup();
+
+ error_fusionee:
+  return ret;
+}
+
+void __exit
+fusion_exit(void)
+{
+  fusion_reactor_cleanup();
+  fusion_property_cleanup();
+  fusion_skirmish_cleanup();
+  fusion_ref_cleanup();
+  fusionee_cleanup();
+
+  misc_deregister (&fusion_miscdev);
+}
+
+module_init(fusion_init);
+module_exit(fusion_exit);
diff -uraN linux-2.4.20/drivers/char/fusion/fusiondev.h linux-2.4.20-fusion/drivers/char/fusion/fusiondev.h
--- linux-2.4.20/drivers/char/fusion/fusiondev.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fusiondev.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,28 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONDEV_H__
+#define __FUSIONDEV_H__
+
+#include <linux/proc_fs.h>
+
+extern struct proc_dir_entry *proc_fusion_dir;
+
+/*
+ * Special version of interruptible_sleep_on() that unlocks the spinlock
+ * after adding the entry to the queue (just before schedule).
+ */
+void fusion_sleep_on(wait_queue_head_t *q, spinlock_t *lock);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/fusionee.c linux-2.4.20-fusion/drivers/char/fusion/fusionee.c
--- linux-2.4.20/drivers/char/fusion/fusionee.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fusionee.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,441 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <asm/uaccess.h>
+
+#include <linux/fusion.h>
+
+#include "call.h"
+#include "fifo.h"
+#include "list.h"
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "property.h"
+#include "reactor.h"
+#include "ref.h"
+#include "skirmish.h"
+
+
+typedef struct {
+  FusionLink        link;
+
+  spinlock_t        lock;
+
+  int               id;
+  int               pid;
+
+  FusionFifo        messages;
+
+  int               rcv_total;  /* Total number of messages received. */
+  int               snd_total;  /* Total number of messages sent. */
+
+  wait_queue_head_t wait;
+} Fusionee;
+
+typedef struct {
+  FusionLink         link;
+
+  FusionMessageType  type;
+  int                id;
+  int                size;
+  void              *data;
+} Message;
+
+/******************************************************************************/
+
+static Fusionee *lookup_fusionee (int id);
+
+static Fusionee *lock_fusionee   (int id);
+static void      unlock_fusionee (Fusionee *fusionee);
+
+/******************************************************************************/
+
+static int         last_id        = 0;
+static FusionLink *fusionees      = NULL;
+static spinlock_t  fusionees_lock = SPIN_LOCK_UNLOCKED;
+static atomic_t    msg_total;
+
+/******************************************************************************/
+
+static int
+fusionees_read_proc(char *buf, char **start, off_t offset,
+                    int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&fusionees_lock);
+
+  fusion_list_foreach (l, fusionees)
+    {
+      Fusionee *fusionee = (Fusionee*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x (%4d messages waiting, %5d received, %5d sent)\n",
+                         fusionee->pid, fusionee->id, fusionee->messages.count, fusionee->rcv_total, fusionee->snd_total);
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&fusionees_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusionee_init()
+{
+  atomic_set (&msg_total, 0);
+
+  create_proc_read_entry("fusionees", 0, proc_fusion_dir,
+                         fusionees_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusionee_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&fusionees_lock);
+
+  l = fusionees;
+  while (l)
+    {
+      FusionLink *next     = l->next;
+      Fusionee   *fusionee = (Fusionee *) l;
+
+      while (fusionee->messages.count)
+        {
+          Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+          kfree (message);
+        }
+
+      kfree (fusionee);
+
+      l = next;
+    }
+
+  last_id   = 0;
+  fusionees = NULL;
+
+  atomic_set (&msg_total, 0);
+
+  spin_unlock (&fusionees_lock);
+}
+
+void
+fusionee_cleanup()
+{
+  fusionee_reset();
+
+  remove_proc_entry ("fusionees", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusionee_new (int *id)
+{
+  Fusionee *fusionee;
+
+  fusionee = kmalloc (sizeof(Fusionee), GFP_KERNEL);
+  if (!fusionee)
+    return -ENOMEM;
+
+  memset (fusionee, 0, sizeof(Fusionee));
+
+  spin_lock (&fusionees_lock);
+
+  fusionee->id   = ++last_id;
+  fusionee->pid  = current->pid;
+  fusionee->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&fusionee->wait);
+
+  fusion_list_prepend (&fusionees, &fusionee->link);
+
+  spin_unlock (&fusionees_lock);
+
+  *id = fusionee->id;
+
+  return 0;
+}
+
+int
+fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
+                       int msg_id, int msg_size, const void *msg_data)
+{
+  Message  *message;
+  Fusionee *sender;
+  Fusionee *fusionee = lock_fusionee (recipient);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  sender = lock_fusionee (id);
+  if (!sender)
+    {
+      unlock_fusionee (fusionee);
+      return -EIO;
+    }
+
+  message = kmalloc (sizeof(Message) + msg_size, GFP_KERNEL);
+  if (!message)
+    {
+      unlock_fusionee (sender);
+      unlock_fusionee (fusionee);
+      return -ENOMEM;
+    }
+
+  message->data = message + 1;
+
+  if (msg_type == FMT_CALL)
+    memcpy (message->data, msg_data, msg_size);
+  else if (copy_from_user (message->data, msg_data, msg_size))
+    {
+      kfree (message);
+      unlock_fusionee (sender);
+      unlock_fusionee (fusionee);
+      return -EFAULT;
+    }
+
+  message->type = msg_type;
+  message->id   = msg_id;
+  message->size = msg_size;
+
+  fusion_fifo_put (&fusionee->messages, &message->link);
+
+  fusionee->rcv_total++;
+  sender->snd_total++;
+
+  atomic_inc (&msg_total);
+
+  wake_up_interruptible_all (&fusionee->wait);
+
+  unlock_fusionee (sender);
+  unlock_fusionee (fusionee);
+
+  return 0;
+}
+
+int
+fusionee_get_messages (int id, void *buf, int buf_size, int block)
+{
+  int       written  = 0;
+  Fusionee *fusionee = lock_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  while (!fusionee->messages.count)
+    {
+      if (!block)
+        {
+          unlock_fusionee (fusionee);
+          return -EAGAIN;
+        }
+
+      fusion_sleep_on (&fusionee->wait, &fusionee->lock);
+
+      if (signal_pending(current))
+        return -ERESTARTSYS;
+
+      fusionee = lock_fusionee (id);
+      if (!fusionee)
+        return -EINVAL;
+    }
+
+  while (fusionee->messages.count)
+    {
+      FusionReadMessage  header;
+      Message           *message = (Message*) fusionee->messages.first;
+      int                bytes   = message->size + sizeof(header);
+
+      if (bytes > buf_size)
+        {
+          if (!written)
+            {
+              unlock_fusionee (fusionee);
+              return -EMSGSIZE;
+            }
+
+          break;
+        }
+
+      header.msg_type = message->type;
+      header.msg_id   = message->id;
+      header.msg_size = message->size;
+
+      if (copy_to_user (buf, &header, sizeof(header)) ||
+          copy_to_user (buf + sizeof(header), message->data, message->size))
+        {
+          unlock_fusionee (fusionee);
+          return -EFAULT;
+        }
+        
+      written  += bytes;
+      buf      += bytes;
+      buf_size -= bytes;
+
+      fusion_fifo_get (&fusionee->messages);
+
+      kfree (message);
+    }
+
+  unlock_fusionee (fusionee);
+
+  return written;
+}
+
+unsigned int
+fusionee_poll (int id, struct file *file, poll_table * wait)
+{
+  Fusionee *fusionee = lock_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  unlock_fusionee (fusionee);
+
+
+  poll_wait (file, &fusionee->wait, wait);
+
+  
+  fusionee = lock_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  if (fusionee->messages.count)
+    {
+      unlock_fusionee (fusionee);
+
+      return POLLIN | POLLRDNORM;
+    }
+
+  unlock_fusionee (fusionee);
+
+  return 0;
+}
+
+int
+fusionee_kill (int id)
+{
+  Fusionee *fusionee = lock_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  kill_proc (fusionee->pid, SIGKILL, 0);
+
+  unlock_fusionee (fusionee);
+
+  return 0;
+}
+
+int
+fusionee_destroy (int id)
+{
+  Fusionee *fusionee = lookup_fusionee (id);
+
+  if (!fusionee)
+    return -EINVAL;
+
+  spin_lock (&fusionee->lock);
+
+  fusion_list_remove (&fusionees, &fusionee->link);
+
+  spin_unlock (&fusionees_lock);
+
+  fusion_call_destroy_all (id);
+  fusion_skirmish_dismiss_all (id);
+  fusion_reactor_detach_all (id);
+  fusion_property_cede_all (id);
+  fusion_ref_clear_all_local (id);
+
+  while (fusionee->messages.count)
+    {
+      Message *message = (Message*) fusion_fifo_get (&fusionee->messages);
+
+      kfree (message);
+    }
+
+  kfree (fusionee);
+
+  return 0;
+}
+
+/******************************************************************************/
+
+static Fusionee *
+lookup_fusionee (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&fusionees_lock);
+
+  fusion_list_foreach (l, fusionees)
+    {
+      Fusionee *fusionee = (Fusionee *) l;
+
+      if (fusionee->id == id)
+        return fusionee;
+    }
+
+  spin_unlock (&fusionees_lock);
+
+  return NULL;
+}
+
+static Fusionee *
+lock_fusionee (int id)
+{
+  Fusionee *fusionee = lookup_fusionee (id);
+
+  if (fusionee)
+    {
+      spin_lock (&fusionee->lock);
+      spin_unlock (&fusionees_lock);
+    }
+
+  return fusionee;
+}
+
+static void
+unlock_fusionee (Fusionee *fusionee)
+{
+  spin_unlock (&fusionee->lock);
+}
diff -uraN linux-2.4.20/drivers/char/fusion/fusionee.h linux-2.4.20-fusion/drivers/char/fusion/fusionee.h
--- linux-2.4.20/drivers/char/fusion/fusionee.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/fusionee.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,46 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSIONEE_H__
+#define __FUSIONEE_H__
+
+#include <linux/poll.h>
+#include <linux/fusion.h>
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusionee_init (void);
+void fusionee_reset (void);
+void fusionee_cleanup (void);
+
+
+/* internal functions */
+
+int fusionee_new (int *id);
+
+int fusionee_send_message (int id, int recipient, FusionMessageType msg_type,
+                           int msg_id, int msg_size, const void *msg_data);
+
+int fusionee_get_messages (int id, void *buf, int buf_size, int block);
+
+unsigned int fusionee_poll (int id, struct file *file, poll_table * wait);
+
+int fusionee_kill (int id);
+
+int fusionee_destroy (int id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/list.c linux-2.4.20-fusion/drivers/char/fusion/list.c
--- linux-2.4.20/drivers/char/fusion/list.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/list.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,62 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/types.h>
+
+#include "list.h"
+
+void
+fusion_list_prepend (FusionLink **list, FusionLink *link)
+{
+     link->prev = NULL;
+     link->next = *list;
+
+     if (*list)
+          (*list)->prev = link;
+
+     *list = link;
+}
+
+void
+fusion_list_remove (FusionLink **list, FusionLink *link)
+{
+     if (link->prev)
+          link->prev->next = link->next;
+     else
+          *list = link->next;
+
+     if (link->next)
+          link->next->prev = link->prev;
+
+     link->next = link->prev = NULL;
+}
+
+void
+fusion_list_move_to_front (FusionLink **list, FusionLink *link)
+{
+  if (*list == link)
+    return;
+
+  link->prev->next = link->next;
+
+  if (link->next)
+    link->next->prev = link->prev;
+
+  link->prev = NULL;
+  link->next = *list;
+
+  (*list)->prev = link;
+
+  *list = link;
+}
diff -uraN linux-2.4.20/drivers/char/fusion/list.h linux-2.4.20-fusion/drivers/char/fusion/list.h
--- linux-2.4.20/drivers/char/fusion/list.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/list.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,33 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __FUSION__LIST_H__
+#define __FUSION__LIST_H__
+
+#include "types.h"
+
+
+typedef struct _FusionLink {
+  struct _FusionLink *next;
+  struct _FusionLink *prev;
+} FusionLink;
+
+void fusion_list_prepend       (FusionLink **list, FusionLink *link);
+void fusion_list_remove        (FusionLink **list, FusionLink *link);
+void fusion_list_move_to_front (FusionLink **list, FusionLink *link);
+
+#define fusion_list_foreach(link, list)  for (link = list; link; link = link->next)
+
+#endif /* __FUSION__LIST_H__ */
+
diff -uraN linux-2.4.20/drivers/char/fusion/Makefile linux-2.4.20-fusion/drivers/char/fusion/Makefile
--- linux-2.4.20/drivers/char/fusion/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/Makefile	2003-04-07 14:51:31.000000000 +0200
@@ -0,0 +1,6 @@
+O_TARGET := fusion.o
+
+obj-y   := call.o fifo.o fusiondev.o fusionee.o list.o property.o reactor.o ref.o skirmish.o
+obj-m   := $(O_TARGET)
+
+include $(TOPDIR)/Rules.make
diff -uraN linux-2.4.20/drivers/char/fusion/property.c linux-2.4.20-fusion/drivers/char/fusion/property.c
--- linux-2.4.20/drivers/char/fusion/property.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/property.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,394 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "property.h"
+
+typedef enum {
+     FUSION_PROPERTY_AVAILABLE = 0,
+     FUSION_PROPERTY_LEASED,
+     FUSION_PROPERTY_PURCHASED
+} FusionPropertyState;
+
+typedef struct {
+  FusionLink          link;
+
+  spinlock_t          lock;
+
+  int                 id;
+  int                 pid;
+
+  FusionPropertyState state;
+  int                 fusion_id; /* non-zero if leased/purchased */
+
+  wait_queue_head_t   wait;
+} FusionProperty;
+
+/******************************************************************************/
+
+static FusionProperty *lookup_property     (int id);
+
+static FusionProperty *lock_property       (int id);
+static void            unlock_property     (FusionProperty *property);
+
+/******************************************************************************/
+
+static int         ids             = 0;
+static FusionLink *properties      = NULL;
+static spinlock_t  properties_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_property_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                         property->pid, property->id,
+                         property->state ?
+                           (property->state == FUSION_PROPERTY_LEASED ?
+                              "leased" : "purchased") :
+                           "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&properties_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_property_init()
+{
+  create_proc_read_entry("properties", 0, proc_fusion_dir,
+                         fusion_property_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_property_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&properties_lock);
+
+  l = properties;
+  while (l)
+    {
+      FusionLink     *next     = l->next;
+      FusionProperty *property = (FusionProperty *) l;
+
+      kfree (property);
+
+      l = next;
+    }
+
+  ids        = 0;
+  properties = NULL;
+
+  spin_unlock (&properties_lock);
+}
+
+void
+fusion_property_cleanup()
+{
+  fusion_property_reset();
+
+  remove_proc_entry ("properties", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_property_new (int *id)
+{
+  FusionProperty *property;
+
+  property = kmalloc (sizeof(FusionProperty), GFP_KERNEL);
+  if (!property)
+    return -ENOMEM;
+
+  memset (property, 0, sizeof(FusionProperty));
+
+  spin_lock (&properties_lock);
+
+  property->id   = ids++;
+  property->pid  = current->pid;
+  property->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&property->wait);
+
+  fusion_list_prepend (&properties, &property->link);
+
+  spin_unlock (&properties_lock);
+
+  *id = property->id;
+
+  return 0;
+}
+
+int
+fusion_property_lease (int id, int fusion_id)
+{
+  FusionProperty *property;
+
+  while (true)
+    {
+      property = lock_property (id);
+      if (!property)
+        return -EINVAL;
+
+      switch (property->state)
+        {
+        case FUSION_PROPERTY_AVAILABLE:
+          property->state     = FUSION_PROPERTY_LEASED;
+          property->fusion_id = fusion_id;
+
+          unlock_property (property);
+          return 0;
+
+        case FUSION_PROPERTY_LEASED:
+          fusion_sleep_on (&property->wait, &property->lock);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+
+          break;
+
+        case FUSION_PROPERTY_PURCHASED:
+          unlock_property (property);
+          return -EAGAIN;
+        }
+    }
+
+  /* won't reach this */
+  return 0;
+}
+
+int
+fusion_property_purchase (int id, int fusion_id)
+{
+  FusionProperty *property;
+
+  while (true)
+    {
+      property = lock_property (id);
+      if (!property)
+        return -EINVAL;
+
+      switch (property->state)
+        {
+        case FUSION_PROPERTY_AVAILABLE:
+          property->state     = FUSION_PROPERTY_PURCHASED;
+          property->fusion_id = fusion_id;
+
+          wake_up_interruptible_all (&property->wait);
+
+          unlock_property (property);
+          return 0;
+
+        case FUSION_PROPERTY_LEASED:
+          fusion_sleep_on (&property->wait, &property->lock);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+
+          break;
+
+        case FUSION_PROPERTY_PURCHASED:
+          unlock_property (property);
+          return -EAGAIN;
+        }
+    }
+
+  /* won't reach this */
+  return 0;
+}
+
+int
+fusion_property_cede (int id, int fusion_id)
+{
+  FusionProperty *property = lock_property (id);
+
+  if (!property)
+    return -EINVAL;
+
+  if (property->fusion_id != fusion_id)
+    {
+      unlock_property (property);
+      return -EIO;
+    }
+
+  property->state     = FUSION_PROPERTY_AVAILABLE;
+  property->fusion_id = 0;
+
+  wake_up_interruptible_all (&property->wait);
+
+  unlock_property (property);
+
+  return 0;
+}
+
+int
+fusion_property_holdup (int id, int fusion_id)
+{
+  FusionProperty *property = lock_property (id);
+
+  if (!property)
+    return -EINVAL;
+
+  if (property->state == FUSION_PROPERTY_PURCHASED)
+    {
+      if (property->fusion_id == fusion_id)
+        {
+          unlock_property (property);
+          return -EIO;
+        }
+
+      fusionee_kill (property->fusion_id);
+    }
+
+  unlock_property (property);
+
+  return 0;
+}
+
+int
+fusion_property_destroy (int id)
+{
+  FusionProperty *property = lookup_property (id);
+
+  if (!property)
+    return -EINVAL;
+
+  spin_lock (&property->lock);
+
+  fusion_list_remove (&properties, &property->link);
+
+  wake_up_interruptible_all (&property->wait);
+
+  spin_unlock (&properties_lock);
+
+  kfree (property);
+
+  return 0;
+}
+
+void
+fusion_property_cede_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty *) l;
+
+      spin_lock (&property->lock);
+
+      if (property->fusion_id == fusion_id)
+        {
+          property->state     = FUSION_PROPERTY_AVAILABLE;
+          property->fusion_id = 0;
+
+          wake_up_interruptible_all (&property->wait);
+        }
+
+      spin_unlock (&property->lock);
+    }
+
+  spin_unlock (&properties_lock);
+}
+
+/******************************************************************************/
+
+static FusionProperty *
+lookup_property (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&properties_lock);
+
+  fusion_list_foreach (l, properties)
+    {
+      FusionProperty *property = (FusionProperty *) l;
+
+      if (property->id == id)
+        return property;
+    }
+
+  spin_unlock (&properties_lock);
+
+  return NULL;
+}
+
+static FusionProperty *
+lock_property (int id)
+{
+  FusionProperty *property = lookup_property (id);
+
+  if (property)
+    {
+      fusion_list_move_to_front (&properties, &property->link);
+
+      spin_lock (&property->lock);
+      spin_unlock (&properties_lock);
+    }
+
+  return property;
+}
+
+static void
+unlock_property (FusionProperty *property)
+{
+  spin_unlock (&property->lock);
+}
diff -uraN linux-2.4.20/drivers/char/fusion/property.h linux-2.4.20-fusion/drivers/char/fusion/property.h
--- linux-2.4.20/drivers/char/fusion/property.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/property.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__PROPERTY_H__
+#define __FUSION__PROPERTY_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_property_init (void);
+void fusion_property_reset (void);
+void fusion_property_cleanup (void);
+
+
+/* public API */
+
+int fusion_property_new (int *id);
+int fusion_property_lease (int id, int fusion_id);
+int fusion_property_purchase (int id, int fusion_id);
+int fusion_property_cede (int id, int fusion_id);
+int fusion_property_holdup (int id, int fusion_id);
+int fusion_property_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_property_cede_all (int fusion_id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/reactor.c linux-2.4.20-fusion/drivers/char/fusion/reactor.c
--- linux-2.4.20/drivers/char/fusion/reactor.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/reactor.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,400 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "reactor.h"
+
+typedef struct {
+  FusionLink         link;
+
+  int                fusion_id;
+
+  int                count;     /* number of attach calls */
+} ReactorNode;
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;
+  int                pid;
+
+  FusionLink        *nodes;
+} FusionReactor;
+
+/******************************************************************************/
+
+static FusionReactor *lookup_reactor     (int id);
+
+static FusionReactor *lock_reactor       (int id);
+static void           unlock_reactor     (FusionReactor *reactor);
+
+static ReactorNode   *get_node           (FusionReactor *reactor,
+                                          int            fusion_id);
+static void           remove_node        (FusionReactor *reactor,
+                                          int            fusion_id);
+static void           free_all_nodes     (FusionReactor *reactor);
+
+/******************************************************************************/
+
+static int         ids           = 0;
+static FusionLink *reactors      = NULL;
+static spinlock_t  reactors_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_reactor_read_proc(char *buf, char **start, off_t offset,
+                         int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&reactors_lock);
+
+  fusion_list_foreach (l, reactors)
+    {
+      FusionReactor *reactor = (FusionReactor*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %s\n", reactor->pid,
+                         reactor->id, reactor->nodes ? "" : "(none attached)");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&reactors_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_reactor_init()
+{
+  create_proc_read_entry("reactors", 0, proc_fusion_dir,
+                         fusion_reactor_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_reactor_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&reactors_lock);
+
+  l = reactors;
+  while (l)
+    {
+      FusionLink    *next    = l->next;
+      FusionReactor *reactor = (FusionReactor *) l;
+
+      free_all_nodes (reactor);
+          
+      kfree (reactor);
+
+      l = next;
+    }
+
+  ids      = 0;
+  reactors = NULL;
+
+  spin_unlock (&reactors_lock);
+}
+
+void
+fusion_reactor_cleanup()
+{
+  fusion_reactor_reset();
+
+  remove_proc_entry ("reactors", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_reactor_new (int *id)
+{
+  FusionReactor *reactor;
+
+  reactor = kmalloc (sizeof(FusionReactor), GFP_KERNEL);
+  if (!reactor)
+    return -ENOMEM;
+
+  memset (reactor, 0, sizeof(FusionReactor));
+
+  spin_lock (&reactors_lock);
+
+  reactor->id   = ids++;
+  reactor->pid  = current->pid;
+  reactor->lock = SPIN_LOCK_UNLOCKED;
+
+  fusion_list_prepend (&reactors, &reactor->link);
+
+  spin_unlock (&reactors_lock);
+
+  *id = reactor->id;
+
+  return 0;
+}
+
+int
+fusion_reactor_attach (int id, int fusion_id)
+{
+  ReactorNode   *node;
+  FusionReactor *reactor = lock_reactor (id);
+
+  if (!reactor)
+    return -EINVAL;
+
+  node = get_node (reactor, fusion_id);
+  if (!node)
+    {
+      node = kmalloc (sizeof(ReactorNode), GFP_KERNEL);
+      if (!node)
+        {
+          unlock_reactor (reactor);
+          return -ENOMEM;
+        }
+
+      node->fusion_id = fusion_id;
+      node->count     = 1;
+
+      fusion_list_prepend (&reactor->nodes, &node->link);
+    }
+  else
+    node->count++;
+
+  unlock_reactor (reactor);
+
+  return 0;
+}
+
+int
+fusion_reactor_detach (int id, int fusion_id)
+{
+  ReactorNode   *node;
+  FusionReactor *reactor = lock_reactor (id);
+
+  if (!reactor)
+    return -EINVAL;
+
+  node = get_node (reactor, fusion_id);
+  if (!node)
+    {
+      unlock_reactor (reactor);
+      return -EIO;
+    }
+
+  if (! --node->count)
+    {
+      fusion_list_remove (&reactor->nodes, &node->link);
+      kfree (node);
+    }
+
+  unlock_reactor (reactor);
+
+  return 0;
+}
+
+int
+fusion_reactor_dispatch (int id, int fusion_id,
+                         int msg_size, const void *msg_data)
+{
+  FusionLink    *l;
+  FusionReactor *reactor = lock_reactor (id);
+
+  if (!reactor)
+    return -EINVAL;
+
+  fusion_list_foreach (l, reactor->nodes)
+    {
+      ReactorNode *node = (ReactorNode *) l;
+
+      if (node->fusion_id == fusion_id)
+        continue;
+
+      fusionee_send_message (fusion_id, node->fusion_id, FMT_REACTOR,
+                             reactor->id, msg_size, msg_data);
+    }
+
+  unlock_reactor (reactor);
+
+  return 0;
+}
+
+int
+fusion_reactor_destroy (int id)
+{
+  FusionReactor *reactor = lookup_reactor (id);
+
+  if (!reactor)
+    return -EINVAL;
+
+  spin_lock (&reactor->lock);
+
+  fusion_list_remove (&reactors, &reactor->link);
+
+  spin_unlock (&reactors_lock);
+
+  free_all_nodes (reactor);
+
+  kfree (reactor);
+
+  return 0;
+}
+
+void
+fusion_reactor_detach_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&reactors_lock);
+
+  fusion_list_foreach (l, reactors)
+    {
+      FusionReactor *reactor = (FusionReactor *) l;
+
+      remove_node (reactor, fusion_id);
+    }
+
+  spin_unlock (&reactors_lock);
+}
+
+/******************************************************************************/
+
+static FusionReactor *
+lookup_reactor (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&reactors_lock);
+
+  fusion_list_foreach (l, reactors)
+    {
+      FusionReactor *reactor = (FusionReactor *) l;
+
+      if (reactor->id == id)
+        return reactor;
+    }
+
+  spin_unlock (&reactors_lock);
+
+  return NULL;
+}
+
+static FusionReactor *
+lock_reactor (int id)
+{
+  FusionReactor *reactor = lookup_reactor (id);
+
+  if (reactor)
+    {
+      fusion_list_move_to_front (&reactors, &reactor->link);
+
+      spin_lock (&reactor->lock);
+      spin_unlock (&reactors_lock);
+    }
+
+  return reactor;
+}
+
+static void
+unlock_reactor (FusionReactor *reactor)
+{
+  spin_unlock (&reactor->lock);
+}
+
+static ReactorNode *
+get_node (FusionReactor *reactor,
+          int            fusion_id)
+{
+  FusionLink *l;
+
+  fusion_list_foreach (l, reactor->nodes)
+    {
+      ReactorNode *node = (ReactorNode *) l;
+
+      if (node->fusion_id == fusion_id)
+        return node;
+    }
+
+  return NULL;
+}
+
+static void
+remove_node (FusionReactor *reactor, int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&reactor->lock);
+
+  fusion_list_foreach (l, reactor->nodes)
+    {
+      ReactorNode *node = (ReactorNode *) l;
+
+      if (node->fusion_id == fusion_id)
+        {
+          fusion_list_remove (&reactor->nodes, l);
+          break;
+        }
+    }
+
+  spin_unlock (&reactor->lock);
+}
+
+static void
+free_all_nodes (FusionReactor *reactor)
+
+{
+  FusionLink *l = reactor->nodes;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+
+      kfree (l);
+
+      l = next;
+    }
+
+  reactor->nodes = NULL;
+}
diff -uraN linux-2.4.20/drivers/char/fusion/reactor.h linux-2.4.20-fusion/drivers/char/fusion/reactor.h
--- linux-2.4.20/drivers/char/fusion/reactor.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/reactor.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__REACTOR_H__
+#define __FUSION__REACTOR_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_reactor_init (void);
+void fusion_reactor_reset (void);
+void fusion_reactor_cleanup (void);
+
+
+/* public API */
+
+int fusion_reactor_new (int *id);
+int fusion_reactor_attach (int id, int fusion_id);
+int fusion_reactor_detach (int id, int fusion_id);
+int fusion_reactor_dispatch (int id, int fusion_id,
+                             int msg_size, const void *msg_data);
+int fusion_reactor_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_reactor_detach_all (int fusion_id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/ref.c linux-2.4.20-fusion/drivers/char/fusion/ref.c
--- linux-2.4.20/drivers/char/fusion/ref.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/ref.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,513 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "list.h"
+#include "ref.h"
+
+typedef struct {
+  FusionLink  link;
+  int         fusion_id;
+  int         refs;
+} LocalRef;
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;
+  int                pid;
+
+  int                global;
+  int                local;
+
+  bool               locked;
+
+  FusionLink        *local_refs;
+
+  wait_queue_head_t  wait;
+} FusionRef;
+
+/******************************************************************************/
+
+static FusionRef *lookup_ref     (int id);
+
+static FusionRef *lock_ref       (int id);
+static void       unlock_ref     (FusionRef *ref);
+
+static int        add_local      (FusionRef *ref, int fusion_id, int add);
+static void       clear_local    (FusionRef *ref, int fusion_id);
+static void       free_all_local (FusionRef *ref);
+
+/******************************************************************************/
+
+static int         ids       = 0;
+static FusionLink *refs      = NULL;
+static spinlock_t  refs_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_ref_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %2d %2d %s\n",
+                         ref->pid, ref->id, ref->global, ref->local,
+                         ref->locked ? "(locked)" : "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&refs_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_ref_init()
+{
+  create_proc_read_entry("refs", 0, proc_fusion_dir,
+                         fusion_ref_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_ref_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&refs_lock);
+
+  l = refs;
+  while (l)
+    {
+      FusionLink *next = l->next;
+      FusionRef  *ref  = (FusionRef *) l;
+
+      free_all_local (ref);
+
+      kfree (ref);
+
+      l = next;
+    }
+
+  ids  = 0;
+  refs = NULL;
+
+  spin_unlock (&refs_lock);
+}
+
+void
+fusion_ref_cleanup()
+{
+  fusion_ref_reset();
+
+  remove_proc_entry ("refs", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_ref_new (int *id)
+{
+  FusionRef *ref;
+
+  ref = kmalloc (sizeof(FusionRef), GFP_KERNEL);
+  if (!ref)
+    return -ENOMEM;
+
+  memset (ref, 0, sizeof(FusionRef));
+
+  spin_lock (&refs_lock);
+
+  ref->id   = ids++;
+  ref->pid  = current->pid;
+  ref->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&ref->wait);
+
+  fusion_list_prepend (&refs, &ref->link);
+
+  spin_unlock (&refs_lock);
+
+  *id = ref->id;
+
+  return 0;
+}
+
+int
+fusion_ref_up (int id, int fusion_id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (fusion_id)
+    {
+      int ret;
+
+      ret = add_local (ref, fusion_id, 1);
+      if (ret)
+        {
+          unlock_ref (ref);
+          return ret;
+        }
+
+      ref->local++;
+    }
+  else
+    ref->global++;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_down (int id, int fusion_id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (fusion_id)
+    {
+      int ret;
+
+      if (!ref->local)
+        return -EIO;
+
+      ret = add_local (ref, fusion_id, -1);
+      if (ret)
+        {
+          unlock_ref (ref);
+          return ret;
+        }
+
+      ref->local--;
+    }
+  else
+    {
+      if (!ref->global)
+        return -EIO;
+
+      ref->global--;
+    }
+
+  if (ref->local + ref->global == 0)
+    wake_up_interruptible_all (&ref->wait);
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_zero_lock (int id)
+{
+  FusionRef *ref;
+
+  while (true)
+    {
+      ref = lock_ref (id);
+      if (!ref)
+        return -EINVAL;
+
+      if (ref->locked)
+        {
+          unlock_ref (ref);
+          return -EAGAIN;
+        }
+
+      if (ref->global || ref->local)
+        {
+          fusion_sleep_on (&ref->wait, &ref->lock);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+        }
+      else
+        break;
+    }
+
+  ref->locked = true;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_zero_trylock (int id)
+{
+  int        ret = 0;
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  if (ref->locked)
+    {
+      unlock_ref (ref);
+      return -EAGAIN;
+    }
+
+  if (ref->global || ref->local)
+    ret = -ETOOMANYREFS;
+  else
+    ref->locked = true;
+
+  unlock_ref (ref);
+
+  return ret;
+}
+
+int
+fusion_ref_unlock (int id)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  ref->locked = false;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_stat (int id, int *refs)
+{
+  FusionRef *ref = lock_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  *refs = ref->global + ref->local;
+
+  unlock_ref (ref);
+
+  return 0;
+}
+
+int
+fusion_ref_destroy (int id)
+{
+  FusionRef *ref = lookup_ref (id);
+
+  if (!ref)
+    return -EINVAL;
+
+  spin_lock (&ref->lock);
+
+  fusion_list_remove (&refs, &ref->link);
+
+  wake_up_interruptible_all (&ref->wait);
+
+  spin_unlock (&refs_lock);
+
+  free_all_local (ref);
+
+  kfree (ref);
+
+  return 0;
+}
+
+void
+fusion_ref_clear_all_local (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef *) l;
+
+      clear_local (ref, fusion_id);
+    }
+
+  spin_unlock (&refs_lock);
+}
+
+/******************************************************************************/
+
+static FusionRef *
+lookup_ref (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&refs_lock);
+
+  fusion_list_foreach (l, refs)
+    {
+      FusionRef *ref = (FusionRef *) l;
+
+      if (ref->id == id)
+        return ref;
+    }
+
+  spin_unlock (&refs_lock);
+
+  return NULL;
+}
+
+static FusionRef *
+lock_ref (int id)
+{
+  FusionRef *ref = lookup_ref (id);
+
+  if (ref)
+    {
+      fusion_list_move_to_front (&refs, &ref->link);
+
+      spin_lock (&ref->lock);
+      spin_unlock (&refs_lock);
+    }
+
+  return ref;
+}
+
+static void
+unlock_ref (FusionRef *ref)
+{
+  spin_unlock (&ref->lock);
+}
+
+static int
+add_local (FusionRef *ref, int fusion_id, int add)
+{
+  FusionLink *l;
+  LocalRef   *local;
+
+  fusion_list_foreach (l, ref->local_refs)
+    {
+      local = (LocalRef *) l;
+
+      if (local->fusion_id == fusion_id)
+        {
+          if (local->refs + add < 0)
+            return -EIO;
+
+          local->refs += add;
+          return 0;
+        }
+    }
+
+  local = kmalloc (sizeof(LocalRef), GFP_KERNEL);
+  if (!local)
+    return -ENOMEM;
+
+  local->fusion_id = fusion_id;
+  local->refs      = add;
+
+  fusion_list_prepend (&ref->local_refs, &local->link);
+
+  return 0;
+}
+
+static void
+clear_local (FusionRef *ref, int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&ref->lock);
+
+  fusion_list_foreach (l, ref->local_refs)
+    {
+      LocalRef *local = (LocalRef *) l;
+
+      if (local->fusion_id == fusion_id)
+        {
+          ref->local -= local->refs;
+
+          if (ref->local + ref->global == 0)
+            wake_up_interruptible_all (&ref->wait);
+
+          fusion_list_remove (&ref->local_refs, l);
+
+          break;
+        }
+    }
+
+  spin_unlock (&ref->lock);
+}
+
+static void
+free_all_local (FusionRef *ref)
+{
+  FusionLink *l = ref->local_refs;
+
+  while (l)
+    {
+      FusionLink *next = l->next;
+
+      kfree (l);
+
+      l = next;
+    }
+
+  ref->local_refs = NULL;
+}
diff -uraN linux-2.4.20/drivers/char/fusion/ref.h linux-2.4.20-fusion/drivers/char/fusion/ref.h
--- linux-2.4.20/drivers/char/fusion/ref.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/ref.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,44 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__REF_H__
+#define __FUSION__REF_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_ref_init (void);
+void fusion_ref_reset (void);
+void fusion_ref_cleanup (void);
+
+
+/* public API */
+
+int fusion_ref_new (int *id);
+int fusion_ref_up (int id, int fusion_id);
+int fusion_ref_down (int id, int fusion_id);
+int fusion_ref_zero_lock (int id);
+int fusion_ref_zero_trylock (int id);
+int fusion_ref_unlock (int id);
+int fusion_ref_stat (int id, int *refs);
+int fusion_ref_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_ref_clear_all_local (int fusion_id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/skirmish.c linux-2.4.20-fusion/drivers/char/fusion/skirmish.c
--- linux-2.4.20/drivers/char/fusion/skirmish.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/skirmish.c	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,357 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/smp_lock.h>
+#include <linux/sched.h>
+
+#include <linux/fusion.h>
+
+#include "fusiondev.h"
+#include "fusionee.h"
+#include "list.h"
+#include "skirmish.h"
+
+typedef struct {
+  FusionLink         link;
+
+  spinlock_t         lock;
+
+  int                id;
+  int                pid;
+
+  int                lock_fid;  /* non-zero if locked */
+  int                lock_pid;
+  int                lock_count;
+
+  wait_queue_head_t  wait;
+} FusionSkirmish;
+
+/******************************************************************************/
+
+static FusionSkirmish *lookup_skirmish     (int id);
+
+static FusionSkirmish *lock_skirmish       (int id);
+static void            unlock_skirmish     (FusionSkirmish *skirmish);
+
+/******************************************************************************/
+
+static int         ids            = 0;
+static FusionLink *skirmishs      = NULL;
+static spinlock_t  skirmishs_lock = SPIN_LOCK_UNLOCKED;
+
+/******************************************************************************/
+
+static int
+fusion_skirmish_read_proc(char *buf, char **start, off_t offset,
+                     int len, int *eof, void *private)
+{
+  FusionLink *l;
+  int written = 0;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish*) l;
+
+      written += sprintf(buf+written, "(%5d) 0x%08x %s\n",
+                         skirmish->pid, skirmish->id,
+                         skirmish->lock_fid ? "(locked)" : "");
+      if (written < offset)
+        {
+          offset -= written;
+          written = 0;
+        }
+
+      if (written >= len)
+        break;
+    }
+
+  spin_unlock (&skirmishs_lock);
+
+  *start = buf + offset;
+  written -= offset;
+  if(written > len)
+    {
+      *eof = 0;
+      return len;
+    }
+
+  *eof = 1;
+  return (written<0) ? 0 : written;
+}
+
+int
+fusion_skirmish_init()
+{
+  create_proc_read_entry("skirmishs", 0, proc_fusion_dir,
+                         fusion_skirmish_read_proc, NULL);
+
+  return 0;
+}
+
+void
+fusion_skirmish_reset()
+{
+  FusionLink *l;
+
+  spin_lock (&skirmishs_lock);
+
+  l = skirmishs;
+  while (l)
+    {
+      FusionLink     *next     = l->next;
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      kfree (skirmish);
+
+      l = next;
+    }
+
+  ids       = 0;
+  skirmishs = NULL;
+
+  spin_unlock (&skirmishs_lock);
+}
+
+void
+fusion_skirmish_cleanup()
+{
+  fusion_skirmish_reset();
+
+  remove_proc_entry ("skirmishs", proc_fusion_dir);
+}
+
+/******************************************************************************/
+
+int
+fusion_skirmish_new (int *id)
+{
+  FusionSkirmish *skirmish;
+
+  skirmish = kmalloc (sizeof(FusionSkirmish), GFP_KERNEL);
+  if (!skirmish)
+    return -ENOMEM;
+
+  memset (skirmish, 0, sizeof(FusionSkirmish));
+
+  spin_lock (&skirmishs_lock);
+
+  skirmish->id   = ids++;
+  skirmish->pid  = current->pid;
+  skirmish->lock = SPIN_LOCK_UNLOCKED;
+
+  init_waitqueue_head (&skirmish->wait);
+
+  fusion_list_prepend (&skirmishs, &skirmish->link);
+
+  spin_unlock (&skirmishs_lock);
+
+  *id = skirmish->id;
+
+  return 0;
+}
+
+int
+fusion_skirmish_prevail (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish;
+
+  while (true)
+    {
+      skirmish = lock_skirmish (id);
+      if (!skirmish)
+        return -EINVAL;
+
+      if (skirmish->lock_fid)
+        {
+          if (skirmish->lock_pid == current->pid)
+            {
+              skirmish->lock_count++;
+              unlock_skirmish (skirmish);
+              return 0;
+            }
+
+          fusion_sleep_on (&skirmish->wait, &skirmish->lock);
+
+          if (signal_pending(current))
+            return -ERESTARTSYS;
+        }
+      else
+        break;
+    }
+
+  skirmish->lock_fid   = fusion_id;
+  skirmish->lock_pid   = current->pid;
+  skirmish->lock_count = 1;
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_swoop (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish = lock_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  if (skirmish->lock_fid)
+    {
+      if (skirmish->lock_pid == current->pid)
+        {
+          skirmish->lock_count++;
+          unlock_skirmish (skirmish);
+          return 0;
+        }
+
+      unlock_skirmish (skirmish);
+
+      return -EAGAIN;
+    }
+
+  skirmish->lock_fid   = fusion_id;
+  skirmish->lock_pid   = current->pid;
+  skirmish->lock_count = 1;
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_dismiss (int id, int fusion_id)
+{
+  FusionSkirmish *skirmish = lock_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  if (skirmish->lock_pid != current->pid)
+    {
+      unlock_skirmish (skirmish);
+      return -EIO;
+    }
+
+  if (--skirmish->lock_count == 0)
+    {
+      skirmish->lock_fid = 0;
+      skirmish->lock_pid = 0;
+
+      wake_up_interruptible_all (&skirmish->wait);
+    }
+
+  unlock_skirmish (skirmish);
+
+  return 0;
+}
+
+int
+fusion_skirmish_destroy (int id)
+{
+  FusionSkirmish *skirmish = lookup_skirmish (id);
+
+  if (!skirmish)
+    return -EINVAL;
+
+  spin_lock (&skirmish->lock);
+
+  fusion_list_remove (&skirmishs, &skirmish->link);
+
+  spin_unlock (&skirmishs_lock);
+
+  wake_up_interruptible_all (&skirmish->wait);
+
+  kfree (skirmish);
+
+  return 0;
+}
+
+void
+fusion_skirmish_dismiss_all (int fusion_id)
+{
+  FusionLink *l;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      spin_lock (&skirmish->lock);
+
+      if (skirmish->lock_fid == fusion_id)
+        {
+          skirmish->lock_fid   = 0;
+          skirmish->lock_pid   = 0;
+          skirmish->lock_count = 0;
+
+          wake_up_interruptible_all (&skirmish->wait);
+        }
+
+      spin_unlock (&skirmish->lock);
+    }
+
+  spin_unlock (&skirmishs_lock);
+}
+
+/******************************************************************************/
+
+static FusionSkirmish *
+lookup_skirmish (int id)
+{
+  FusionLink *l;
+
+  spin_lock (&skirmishs_lock);
+
+  fusion_list_foreach (l, skirmishs)
+    {
+      FusionSkirmish *skirmish = (FusionSkirmish *) l;
+
+      if (skirmish->id == id)
+        return skirmish;
+    }
+
+  spin_unlock (&skirmishs_lock);
+
+  return NULL;
+}
+
+static FusionSkirmish *
+lock_skirmish (int id)
+{
+  FusionSkirmish *skirmish = lookup_skirmish (id);
+
+  if (skirmish)
+    {
+      fusion_list_move_to_front (&skirmishs, &skirmish->link);
+
+      spin_lock (&skirmish->lock);
+      spin_unlock (&skirmishs_lock);
+    }
+
+  return skirmish;
+}
+
+static void
+unlock_skirmish (FusionSkirmish *skirmish)
+{
+  spin_unlock (&skirmish->lock);
+}
diff -uraN linux-2.4.20/drivers/char/fusion/skirmish.h linux-2.4.20-fusion/drivers/char/fusion/skirmish.h
--- linux-2.4.20/drivers/char/fusion/skirmish.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/skirmish.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,41 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__SKIRMISH_H__
+#define __FUSION__SKIRMISH_H__
+
+#include "types.h"
+
+
+/* module init/cleanup */
+
+int  fusion_skirmish_init (void);
+void fusion_skirmish_reset (void);
+void fusion_skirmish_cleanup (void);
+
+
+/* public API */
+
+int fusion_skirmish_new (int *id);
+int fusion_skirmish_prevail (int id, int fusion_id);
+int fusion_skirmish_swoop (int id, int fusion_id);
+int fusion_skirmish_dismiss (int id, int fusion_id);
+int fusion_skirmish_destroy (int id);
+
+
+/* internal functions */
+
+void fusion_skirmish_dismiss_all (int fusion_id);
+
+#endif
diff -uraN linux-2.4.20/drivers/char/fusion/types.h linux-2.4.20-fusion/drivers/char/fusion/types.h
--- linux-2.4.20/drivers/char/fusion/types.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/fusion/types.h	2003-04-07 14:54:47.000000000 +0200
@@ -0,0 +1,23 @@
+/*
+ *	Fusion Kernel Module
+ *
+ *	(c) Copyright 2002  Convergence GmbH
+ *
+ *      Written by Denis Oliver Kropp <dok@directfb.org>
+ *
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef __FUSION__TYPES_H__
+#define __FUSION__TYPES_H__
+
+typedef enum {
+  false = 0,
+  true  = !false
+} bool;
+
+#endif
diff -uraN linux-2.4.20/drivers/char/Makefile linux-2.4.20-fusion/drivers/char/Makefile
--- linux-2.4.20/drivers/char/Makefile	2002-11-29 13:18:31.000000000 +0100
+++ linux-2.4.20-fusion/drivers/char/Makefile	2003-04-07 14:51:31.000000000 +0200
@@ -289,6 +289,12 @@
   obj-y += mwave/mwave.o
 endif
 
+subdir-$(CONFIG_FUSION_DEVICE) += fusion
+ifeq ($(CONFIG_FUSION_DEVICE),y)
+  obj-y += fusion/fusion.o
+endif
+
+
 include $(TOPDIR)/Rules.make
 
 fastdep:
diff -uraN linux-2.4.20/include/linux/fusion.h linux-2.4.20-fusion/include/linux/fusion.h
--- linux-2.4.20/include/linux/fusion.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.4.20-fusion/include/linux/fusion.h	2003-04-07 14:54:21.000000000 +0200
@@ -0,0 +1,129 @@
+#ifndef __LINUX__FUSION_H__
+#define __LINUX__FUSION_H__
+
+#include <asm/ioctl.h>
+#include <asm/types.h>
+
+/*
+ * Sending
+ */
+typedef struct {
+  int         fusion_id;      /* recipient */
+
+  int         msg_id;         /* optional message identifier */
+  int         msg_size;       /* message size, must be greater than zero */
+  const void *msg_data;       /* message data, must not be NULL */
+} FusionSendMessage;
+
+/*
+ * Receiving
+ */
+typedef enum {
+  FMT_SEND,
+  FMT_CALL,                   /* msg_id is the call id */
+  FMT_REACTOR                 /* msg_id is the reactor id */
+} FusionMessageType;
+
+typedef struct {
+  FusionMessageType msg_type;
+
+  int               msg_id;
+  int               msg_size;
+
+  /* message data follows */
+} FusionReadMessage;
+
+/*
+ * Dispatching
+ */
+typedef struct {
+  int         reactor_id;
+  int         self;
+
+  int         msg_size;       /* message size, must be greater than zero */
+  const void *msg_data;       /* message data, must not be NULL */
+} FusionReactorDispatch;
+
+/*
+ * Calling (synchronous RPC)
+ */
+typedef int (*FusionCallHandler) (int   caller,   /* fusion id of the caller */
+                                  int   call_arg, /* optional call parameter */
+                                  void *call_ptr, /* optional call parameter */
+                                  void *ctx       /* optional handler context */
+                                  );
+
+typedef struct {
+  int                call_id;   /* new call id returned */
+
+  FusionCallHandler  handler;   /* function pointer of handler to install */
+  void              *ctx;       /* optional handler context */
+} FusionCallNew;
+
+typedef struct {
+  int   ret_val;              /* return value of the call */
+
+  int   call_id;              /* each call has a fixed owner */
+  
+  int   call_arg;             /* optional int argument */
+  void *call_ptr;             /* optional pointer argument (e.g. shared memory) */
+} FusionCallExecute;
+
+
+typedef struct {
+  int   call_id;              /* id of currently executing call */
+
+  int   val;                  /* value to return */
+} FusionCallReturn;
+
+typedef struct {
+  FusionCallHandler  handler;   /* function pointer of handler to call */
+  void              *ctx;       /* optional handler context */
+
+  int                caller;    /* fusion id of the caller */
+  int                call_arg;  /* optional call parameter */
+  void              *call_ptr;  /* optional call parameter */
+} FusionCallMessage;
+  
+
+
+#define FUSION_GET_ID                   _IOR('F', 0x00, sizeof(int))
+
+#define FUSION_SEND_MESSAGE             _IOW('F', 0x01, sizeof(FusionSendMessage))
+
+#define FUSION_CALL_NEW                 _IOW('F', 0x02, sizeof(FusionCallNew))
+#define FUSION_CALL_EXECUTE             _IOW('F', 0x03, sizeof(FusionCallExecute))
+#define FUSION_CALL_RETURN              _IOW('F', 0x04, sizeof(FusionCallReturn))
+#define FUSION_CALL_DESTROY             _IOW('F', 0x05, sizeof(int))
+
+#define FUSION_REF_NEW                  _IOW('F', 0x10, sizeof(int))
+#define FUSION_REF_UP                   _IOW('F', 0x11, sizeof(int))
+#define FUSION_REF_UP_GLOBAL            _IOW('F', 0x12, sizeof(int))
+#define FUSION_REF_DOWN                 _IOW('F', 0x13, sizeof(int))
+#define FUSION_REF_DOWN_GLOBAL          _IOW('F', 0x14, sizeof(int))
+#define FUSION_REF_ZERO_LOCK            _IOW('F', 0x15, sizeof(int))
+#define FUSION_REF_ZERO_TRYLOCK         _IOW('F', 0x16, sizeof(int))
+#define FUSION_REF_UNLOCK               _IOW('F', 0x17, sizeof(int))
+#define FUSION_REF_STAT                 _IOW('F', 0x18, sizeof(int))
+#define FUSION_REF_DESTROY              _IOW('F', 0x19, sizeof(int))
+
+#define FUSION_SKIRMISH_NEW             _IOW('F', 0x20, sizeof(int))
+#define FUSION_SKIRMISH_PREVAIL         _IOW('F', 0x21, sizeof(int))
+#define FUSION_SKIRMISH_SWOOP           _IOW('F', 0x22, sizeof(int))
+#define FUSION_SKIRMISH_DISMISS         _IOW('F', 0x23, sizeof(int))
+#define FUSION_SKIRMISH_DESTROY         _IOW('F', 0x24, sizeof(int))
+
+#define FUSION_PROPERTY_NEW             _IOW('F', 0x30, sizeof(int))
+#define FUSION_PROPERTY_LEASE           _IOW('F', 0x31, sizeof(int))
+#define FUSION_PROPERTY_PURCHASE        _IOW('F', 0x32, sizeof(int))
+#define FUSION_PROPERTY_CEDE            _IOW('F', 0x33, sizeof(int))
+#define FUSION_PROPERTY_HOLDUP          _IOW('F', 0x34, sizeof(int))
+#define FUSION_PROPERTY_DESTROY         _IOW('F', 0x35, sizeof(int))
+
+#define FUSION_REACTOR_NEW              _IOW('F', 0x50, sizeof(int))
+#define FUSION_REACTOR_ATTACH           _IOW('F', 0x51, sizeof(int))
+#define FUSION_REACTOR_DETACH           _IOW('F', 0x52, sizeof(int))
+#define FUSION_REACTOR_DISPATCH         _IOW('F', 0x53, sizeof(FusionReactorDispatch))
+#define FUSION_REACTOR_DESTROY          _IOW('F', 0x54, sizeof(int))
+
+#endif
diff -uraN linux-2.4.20/include/linux/miscdevice.h linux-2.4.20-fusion/include/linux/miscdevice.h
--- linux-2.4.20/include/linux/miscdevice.h	2002-11-01 13:33:02.000000000 +0100
+++ linux-2.4.20-fusion/include/linux/miscdevice.h	2003-04-07 14:51:31.000000000 +0200
@@ -14,6 +14,7 @@
 #define PC110PAD_MINOR 9
 #define ADB_MOUSE_MINOR 10
 #define MK712_MINOR 15			/* MK712 touch screen */
+#define FUSION_MINOR		 23	/* Fusion Device      */
 #define WATCHDOG_MINOR		130	/* Watchdog timer     */
 #define TEMP_MINOR		131	/* Temperature Sensor */
 #define RTC_MINOR 135
